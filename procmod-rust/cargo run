extern crate sdl2;

use sdl2::pixels::Color;
use sdl2::event::Event;
use std::time::Duration;

pub fn main() {
	let sdl_context = sdl2::init().unwrap();
	let video_subsystem = sdl_context.video().unwrap();

	let window = video_subsystem.window("procmodl", 1200, 600)
		.position_centered()
		.build()
		.unwrap();

	let mut canvas = window.into_canvas().build().unwrap();

	canvas.set_draw_color(Color::RGB(18, 20, 23));
	canvas.clear();
	canvas.present();
	let mut event_pump = sdl_context.event_pump().unwrap();
	let mut i = 0;
	'running: loop {
		i = (i + 1) % 255;
		// canvas.set_draw_color(Color::RGB(i, 64, 255 - i));
		canvas.clear();
		for event in event_pump.poll_iter() {
			match event {
				Event::Quit {..} => {
					break 'running
				},
				_ => {}
			}
		}
		// The rest of the game loop goes here...

		canvas.present();
		::std::thread::sleep(Duration::new(0, 1_000_000_000u32 / 60)); // TODO: simple adaptive sleep time
	}
}
/* #[macro_use]
 * extern crate glium;
 * 
 * fn main() {
 *	   use glium::{glutin, Surface};
 * 
 *	   let event_loop = glutin::event_loop::EventLoop::new();
 *	   let wb = glutin::window::WindowBuilder::new().with_title("procmodl");
 *	   let cb = glutin::ContextBuilder::new();
 *	   let display = glium::Display::new(wb, cb, &event_loop).unwrap();
 * 
 *	   #[derive(Copy, Clone)]
 *	   struct Vertex {
 *		   position: [f32; 2],
 *	   }
 *	   
 *	   implement_vertex!(Vertex, position);
 * 
 *	   let vertex1 = Vertex { position: [-0.5, -0.5] };
 *	   let vertex2 = Vertex { position: [ 0.0,	0.5] };
 *	   let vertex3 = Vertex { position: [ 0.5, -0.25] };
 *	   let shape = vec![vertex1, vertex2, vertex3];
 * 
 *	   let vertex_buffer = glium::VertexBuffer::new(&display, &shape).unwrap();
 *	   let indices = glium::index::NoIndices(glium::index::PrimitiveType::TrianglesList);
 * 
 *	   let vertex_shader_src = r#"
 *		   #version 140
 *		   in vec2 position;
 *		   void main() {
 *			   gl_Position = vec4(position, 0.0, 1.0);
 *		   }
 *	   "#;
 * 
 *	   let fragment_shader_src = r#"
 *		   #version 140
 *		   out vec4 color;
 *		   void main() {
 *			   color = vec4(1.0, 0.0, 0.0, 1.0);
 *		   }
 *	   "#;
 * 
 *	   let program = glium::Program::from_source(&display, vertex_shader_src, fragment_shader_src, None).unwrap();
 *	   event_loop.run(move |event, _, control_flow| {
 *		   let next_frame_time = std::time::Instant::now() +
 *			   std::time::Duration::from_nanos(16_666_667);
 *		   *control_flow = glutin::event_loop::ControlFlow::WaitUntil(next_frame_time);
 * 
 *		   match event {
 *			   glutin::event::Event::WindowEvent { event, .. } => match event {
 *				   glutin::event::WindowEvent::CloseRequested => {
 *					   *control_flow = glutin::event_loop::ControlFlow::Exit;
 *					   return;
 *				   },
 *				   _ => return,
 *			   },
 *			   glutin::event::Event::NewEvents(cause) => match cause {
 *				   glutin::event::StartCause::ResumeTimeReached { .. } => (),
 *				   glutin::event::StartCause::Init => (),
 *				   _ => return,
 *			   },
 *			   _ => return,
 *		   }
 * 
 *		   let mut target = display.draw();
 *		   target.clear_color(0.070, 0.078, 0.090, 1.0);
 *		   target.draw(&vertex_buffer, &indices, &program, &glium::uniforms::EmptyUniforms,
 *					   &Default::default()).unwrap();
 *		   target.finish().unwrap();
 *	   });
 * } */
